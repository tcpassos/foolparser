package fool;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;

parser code {:
    private IntermediateCode code = new IntermediateCode();
    private int tempCount = 0;

    private String newTemp() {
        return "t" + tempCount++;
    }

    public String getIntermediateCode() {
        return code.generate();
    }

    public void report_error(String message, Object info) {
        Symbol symbol = (Symbol) info;
        String error = "Token '" + symbol.value + "' encontrado n√£o esperado.";
        System.err.println(error);
        super.report_error(message, info);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        throw new RuntimeException("Erro fatal de sintaxe. Parsing abortado.");
    }
:}

terminal CLASS, VOID, INT, BOOL, IF, ELSE, RETURN, EQ, LT, GT, PLUS, TIMES, ASSIGN, NOT, AND, OR, LPAREN, RPAREN, LBRACE, RBRACE, SEMICOLON, COMMA, WHILE;
terminal String IDENTIFIER;
terminal Integer INT_CONST;
terminal Boolean TRUE, FALSE;

non terminal program;
non terminal class_decl;
non terminal List<CodeFragment> decl_list;
non terminal CodeFragment declaration;
non terminal CodeFragment var_decl;
non terminal Method method_decl;
non terminal MethodCall method_call;
non terminal Type var_type;
non terminal Statement stmt;
non terminal List<Statement> stmt_list;
non terminal Expression expr;
non terminal List<Expression> expr_list;
non terminal List<Expression> expr_list_non_empty;
non terminal List<Variable> arg_list;
non terminal List<Variable> arg_list_non_empty;

precedence left ELSE;
precedence nonassoc IF;
precedence left OR;
precedence left AND;
precedence left EQ;
precedence left LT, GT;
precedence left PLUS;
precedence left TIMES;
precedence right NOT;

start with program;

program ::= class_decl;

class_decl ::= LBRACE CLASS IDENTIFIER decl_list:l RBRACE
                {:
                    l.forEach(code::append);
                :};

decl_list ::= /* vazio */
                {:
                    RESULT = new ArrayList<>();
                :}
            | decl_list:l declaration:d
                {:
                    l.add(d);
                    RESULT = l;
                :};

declaration ::= var_decl:vd
                {:
                    RESULT = vd;
                :}
              | method_decl:md
                {:
                    RESULT = md;
                :};

var_decl ::= var_type:vt IDENTIFIER:var_name SEMICOLON
                {:
                    RESULT = new Variable(vt, var_name);
                :};

method_decl ::= var_type:rt IDENTIFIER:id LPAREN arg_list:args RPAREN LBRACE stmt_list:sl RBRACE
                {:
                    Method method = new Method(rt, id, args, sl);
                    RESULT = method;
                :}
            | VOID IDENTIFIER:id LPAREN arg_list:args RPAREN LBRACE stmt_list:sl RBRACE
                {:
                    Method method = new Method(Type.VOID, id, args, sl);
                    RESULT = method;
                :};

arg_list ::= /* vazio */
           | arg_list_non_empty:l
                {:
                    RESULT = l;
                :};

arg_list_non_empty ::= var_type:t IDENTIFIER:id
                        {:
                            RESULT = new ArrayList<>();
                            RESULT.add(new Variable(t, id));
                        :}
                     | arg_list_non_empty:l COMMA var_type:t IDENTIFIER:id
                        {:
                            l.add(new Variable(t, id));
                            RESULT = l;
                        :};

var_type ::= INT   {: RESULT = Type.INT; :}
           | BOOL  {: RESULT = Type.BOOL; :};

method_call ::= IDENTIFIER:method_name LPAREN expr_list:args RPAREN
                {:
                    RESULT = new MethodCall(method_name, args, newTemp());
                :};

stmt_list ::= /* vazio */
                {:
                    RESULT = new ArrayList<>();
                :}
            | stmt_list:l stmt:s
                {:
                    l.add(s);
                    RESULT = l;
                :};

stmt ::= IDENTIFIER:id ASSIGN expr:e SEMICOLON
            {:
                RESULT = new AssignmentStatement(id, e);
            :}
       | IF LPAREN expr:condition RPAREN stmt:then
            {:
                String thenLabel = code.appendLabel(then);
                RESULT = new IfStatement(condition, thenLabel);
            :}
       | IF LPAREN expr:condition RPAREN stmt:thenStmt ELSE stmt:elseStmt
            {:
                String thenLabel = code.appendLabel(thenStmt);
                String elseLabel = code.appendLabel(elseStmt);
                RESULT = new IfElseStatement(condition, thenLabel, elseLabel);
            :}
       | RETURN expr:e SEMICOLON
            {:
                RESULT = new ReturnStatement(e);
            :}
       | WHILE LPAREN expr:condition RPAREN stmt:stmt
            {:
                RESULT = new WhileStatement(condition, code.appendLabel(stmt));
            :}
       | method_call:mc SEMICOLON
            {:
                RESULT = new MethodCallStatement(mc.getMethodName(), mc.getArguments(), mc.getResult());
            :};

expr ::= expr:e1 PLUS expr:e2
          {:
              RESULT = new Expression("+", e1.getResult(), e2.getResult(), newTemp());
          :}
       | expr:e1 TIMES expr:e2
          {:
              RESULT = new Expression("*", e1.getResult(), e2.getResult(), newTemp());
          :}
       | expr:e1 EQ expr:e2
          {:
              RESULT = new Expression("==", e1.getResult(), e2.getResult(), newTemp());
          :}
       | expr:e1 LT expr:e2
          {:
              RESULT = new Expression("<", e1.getResult(), e2.getResult(), newTemp());
          :}
       | expr:e1 GT expr:e2
          {:
              RESULT = new Expression(">", e1.getResult(), e2.getResult(), newTemp());
          :}
       | expr:e1 AND expr:e2
          {:
              RESULT = new Expression("and", e1.getResult(), e2.getResult(), newTemp());
          :}
       | expr:e1 OR expr:e2
          {:
              RESULT = new Expression("or", e1.getResult(), e2.getResult(), newTemp());
          :}
       | NOT expr:e
          {:
              RESULT = new Expression("not", e.getResult(), newTemp());
          :}
       | TRUE
          {:
              RESULT = new Expression("true");
          :}
       | FALSE
          {:
              RESULT = new Expression("false");
          :}
       | INT_CONST:ic
          {:
              RESULT = new Expression(ic.toString());
          :}
       | IDENTIFIER:id
          {:
              RESULT = new Expression(id);
          :}
       | method_call:mc
          {:
                RESULT = mc;
           :}
       | LPAREN expr:e RPAREN
          {:
              RESULT = e;
          :};

expr_list ::= /* vazio */
            | expr_list_non_empty:l
                {:
                    RESULT = l;
                :};

expr_list_non_empty ::= expr:e
                          {:
                            RESULT = new ArrayList<>();
                            RESULT.add(e);
                          :}
                      | expr_list_non_empty:l COMMA expr:e
                          {:
                            l.add(e);
                            RESULT = l;
                          :};