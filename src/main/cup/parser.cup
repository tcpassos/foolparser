package fool;

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;

parser code {:
    private List<TACInstruction> tacInstructions = new ArrayList<>();
    private int tempCount = 0;

    private String newTemp() {
        return "t" + tempCount++;
    }

    public List<TACInstruction> getTacInstructions() {
        return tacInstructions;
    }

    public void report_error(String message, Object info) {
        Symbol symbol = (Symbol) info;
        String error = "Token '" + symbol.value + "' encontrado não esperado.";
        System.err.println(error);
        super.report_error(message, info);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        throw new RuntimeException("Erro fatal de sintaxe. Parsing abortado.");
    }
:}

terminal CLASS, VOID, INT, BOOL, IF, ELSE, RETURN, EQ, LT, GT, PLUS, TIMES, ASSIGN, NOT, AND, OR, LPAREN, RPAREN, LBRACE, RBRACE, SEMICOLON, COMMA;
terminal String IDENTIFIER;
terminal Integer INT_CONST;
terminal Boolean TRUE, FALSE;

non terminal program;
non terminal class_decl;
non terminal decl_list;
non terminal declaration;
non terminal var_decl;
non terminal method_decl;
non terminal var_type;
non terminal String stmt;
non terminal stmt_list;
non terminal String expr;
non terminal arg_list;
non terminal arg_list_non_empty;
non terminal List<String> expr_list;
non terminal expr_list_non_empty;

precedence left ELSE;
precedence nonassoc IF;
precedence left OR;
precedence left AND;
precedence left EQ;
precedence left LT, GT;
precedence left PLUS;
precedence left TIMES;
precedence right NOT;

start with program;

program ::= class_decl;

class_decl ::= LBRACE CLASS IDENTIFIER decl_list RBRACE;

decl_list ::= /* vazio */
            | decl_list declaration;

declaration ::= var_decl
              | method_decl;

var_decl ::= var_type IDENTIFIER SEMICOLON;

method_decl ::= var_type IDENTIFIER LPAREN arg_list RPAREN LBRACE stmt_list RBRACE
              | VOID IDENTIFIER LPAREN arg_list RPAREN LBRACE stmt_list RBRACE;

arg_list ::= /* vazio */
           | arg_list_non_empty;

arg_list_non_empty ::= var_type IDENTIFIER
                     | arg_list_non_empty COMMA var_type IDENTIFIER;

var_type ::= INT
           | BOOL;

stmt_list ::= /* vazio */
            | stmt_list stmt;

stmt ::= IDENTIFIER:id ASSIGN expr:e SEMICOLON
            {:
                tacInstructions.add(new TACInstruction("=", e, id));
            :}
       | IF LPAREN expr RPAREN stmt
       | IF LPAREN expr RPAREN stmt ELSE stmt
       | RETURN expr SEMICOLON;

expr ::= expr:e1 PLUS expr:e2
          {:
              String temp = newTemp();
              tacInstructions.add(new TACInstruction("+", e1, e2, temp));
              RESULT = temp;
          :}
       | expr:e1 TIMES expr:e2
          {:
              String temp = newTemp();
              tacInstructions.add(new TACInstruction("*", e1, e2, temp));
              RESULT = temp;
          :}
       | expr:e1 EQ expr:e2
          {:
              String temp = newTemp();
              tacInstructions.add(new TACInstruction("==", e1, e2, temp));
              RESULT = temp;
          :}
       | expr:e1 LT expr:e2
          {:
              String temp = newTemp();
              tacInstructions.add(new TACInstruction("<", e1, e2, temp));
              RESULT = temp;
          :}
       | expr:e1 GT expr:e2
          {:
              String temp = newTemp();
              tacInstructions.add(new TACInstruction(">", e1, e2, temp));
              RESULT = temp;
          :}
       | expr:e1 AND expr:e2
          {:
              String temp = newTemp();
              tacInstructions.add(new TACInstruction("and", e1, e2, temp));
              RESULT = temp;
          :}
       | expr:e1 OR expr:e2
          {:
              String temp = newTemp();
              tacInstructions.add(new TACInstruction("or", e1, e2, temp));
              RESULT = temp;
          :}
       | NOT expr:e
          {:
              String temp = newTemp();
              tacInstructions.add(new TACInstruction("not", e, temp));
              RESULT = temp;
          :}
       | TRUE
          {:
              RESULT = "true";
          :}
       | FALSE
          {:
              RESULT = "false";
          :}
       | INT_CONST:ic
          {:
              RESULT = ic.toString();
          :}
       | IDENTIFIER:id
          {:
              RESULT = id;
          :}
       | IDENTIFIER:id LPAREN expr_list:args RPAREN
          {:
              // Implementação para chamadas de função
          :}
       | LPAREN expr:e RPAREN
          {:
              RESULT = e;
          :};

expr_list ::= /* vazio */
            | expr_list_non_empty;

expr_list_non_empty ::= expr
                      | expr_list_non_empty COMMA expr;